const CONTINUE = 0;
const SOLUTION = 1;
const PRUNE = 2;

function solve(desejadas, disponiveis, cmin, cmax, bmin, bmax) {
    const choice = [];
    for (const turma of desejadas) {
        choice.push(turma);
    }
    rsolve(disponiveis, cmin, cmax, bmin, bmax, choice, []);
    postMessage({done: true});
}

function rsolve(disponiveis, cmin, cmax, bmin, bmax, choice, seen) {
    const queue = [[disponiveis, choice]];

    while (queue.length > 0) {
        ([disponiveis, choice] = queue.shift());
        for (const d in disponiveis) {
            if (disponiveis[d] === undefined) debugger;
            var prune = false;
            for (const c of choice) {
                if (disponiveis[d].disc === c.disc) {
                    prune = true;
                    break;
                }
            }
            if (prune) continue;
            choice.push(disponiveis[d]);
            const v = validate(cmin, cmax, bmin, bmax, choice, seen);
            if (v == SOLUTION) {
                postMessage({solution: [...choice]});
            }
            if (v != PRUNE) {
                var tmp = disponiveis[d];
                delete disponiveis[d];
                queue.push([Object.assign({}, disponiveis), [...choice]]);
                disponiveis[d] = tmp;
            }
            choice.pop(disponiveis[d]);
        }
    }
}

function flattenChoices(choice) {
    const flattened = [];
    for (const a of choice) {
        for (const h of a.horarios) {
            const d = h.dia * 1000 + h.inicio;
            flattened.push([h.dia, h.inicio, h.fim, a, d]);
        }
    }
    return flattened.sort((a, b) => a[4] - b[4]);
}

function alreadySeen(seen, flattened) {
    for (const s of seen) {
        var equal = true;
        for (var i = 0; i < flattened.length; i++) {
            if (i >= s.length || s[i][3].disc !== flattened[i][3].disc && s[i][4] != flattened[i][4]) {
                equal = false;
                break;
            }
        }
        if (equal) return true;
    }
    return false;
}

function validate(cmin, cmax, bmin, bmax, choice, seen) {
    const flattened = flattenChoices(choice);
    if (alreadySeen(seen, flattened)) {
        return PRUNE;
    }
    seen.push(flattened);

    var cred = 0;
    var hasBuraco = false;
    for (var i = 1; i < flattened.length; i++) {
        const a = flattened[i-1];
        const b = flattened[i];
        if (a[0] == b[0]) {
            const d = b[1] - a[2];
            if (d < 0) {
                return PRUNE;
            } else if (d > 2 && d-2 > bmin && d-2 < bmax) {
                hasBuraco = true;
                break;
            }
        }
    }
    for (const a of flattened) {
        if (a[3].disc !== 'R') {
            cred += Math.round((a[2] - a[1])/5);
        }
    }

    if (cred < cmin) return CONTINUE;
    if (cred > cmax) return PRUNE;
    if (!hasBuraco) return SOLUTION;
    if (cred < cmax) return CONTINUE;
    return PRUNE;
}

onmessage = function(e) {
    solve(...e.data);
}
